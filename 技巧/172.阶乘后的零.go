
/*
主要思路：
在计算阶乘 n! 时，每个数都来自因子 10（可分解为 2×5）。由于因子 2 的数量通常多于因子 5，所以主要需要计算因子 5 的数量。也就是为什么要把p成5。
在n！中，每个因子5都来自于一个能被5整除的数。
例如：5、10、15、20等都贡献了至少一个因子5，但是25、50、75等贡献了2个因子，125贡献了3个因子5，以此类推。在计算总因子5数量时，就是分别把不同贡献度的数目累加求和。
总数目求和公式：1*贡献一个因子的数字 + 2 * 贡献两个因子的数字 + 3 * 贡献三个因子的数字……
对于任意一项，以计算只贡献一个因子的数字来举例：
能被25整除的，一定能被5整除，这里就对应题解中的floor（n/5）被5整除，floor（n/25）被25整除。因此floor（n/5）- floor（n/25）得到的是只能被5整数而不能被25整除的数目。也就是找到了那些只贡献一个因子5的数字个数。类推可以找到只贡献两个因子5的数字个数，最后再把各项的个数加起来，即得到了因子5的数量。

对于代码：
第一次循环：n/5 计算了能被 5 整除的数的个数
第二次循环：n/25 计算了能被 25 整除的数的个数（这些数贡献了额外的因子 5）
第三次循环：n/125 计算了能被 125 整除的数的个数
以此类推，直到 n 变为 0

举个例子，如果 n = 25：
第一次：25/5 = 5，ans = 5
第二次：5/5 = 1，ans = 6
第三次：1/5 = 0，循环结束
所以 25! 末尾有 6 个零
*/
//类似的 如果是其他的就求自最大的质因子
func trailingZeroes(n int) int {
	ans := 0
	for n > 0 {
		n /= 5
		ans += n
	}
	return ans
}